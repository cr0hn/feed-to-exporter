import abc
import json
import os.path
import datetime

from typing import Callable, List
from types import SimpleNamespace

from pluginbase import PluginBase

from .exceptions import FeedToWordpressException, \
    FeedToWordpressNotValidInfoFound


class AbstractFeedInfo(object):

    def __init__(self,
                 app_config,
                 raw_feed_info: dict,
                 **kwargs):
        """
        properties in Kwargs:

        - title: str
        - feed_source: str
        - date: str
        """
        self.app_config = app_config
        self.raw_feed_info = raw_feed_info

        self.title: str = kwargs.get("title", "")
        self.feed_source: str = kwargs.get("feed_source", "")
        self.date: str = kwargs.get(
            "date",
            datetime.datetime.now().strftime("%Y-%m-%dT%H:%M:%S")
        )

        self._generated_fields_by_filters = set()
        self._tags = {}
        self._categories = {}

    def _update_fields_from_validator(self, source: str, new_values: dict):
        # Update value of fields returned by filter
        for f_name, f_value in new_values.items():
            if hasattr(self, f_name):
                if not f_value:
                    continue

                # If already has a value and is not a list or a dict -> raise
                v = getattr(self, f_name)
                f_type = type(v)
                if f_type.__name__ == "list":
                    v.append(f_value)
                elif f_type.__name__ == "dict":
                    v.update(f_value)
                else:
                    setattr(self, f_name, f_value)

            else:
                raise FeedToWordpressException(
                    f"Filter '{source}' returns invalid "
                    f"field to update: {f_name}"
                )

        # Update fields generated by filters
        self._generated_fields_by_filters.update(new_values.keys())

    def _apply_filter(self, field_name: str, filter_function: Callable):
        attr_value = getattr(self, field_name)

        # Apply the filter
        filter_result = filter_function(attr_value)

        # Check result format
        if not isinstance(filter_result, dict):
            raise FeedToWordpressException(
                f"Filter '{filter_function.__name__}' returns invalid "
                f"type: '{type(filter_result)}'. Only allowed type: dict"
            )

        # Update fields with new values
        self._update_fields_from_validator(filter_function.__name__,
                                           filter_result)

    def apply_global_validator(self) -> \
            bool or FeedToWordpressNotValidInfoFound:

        result = self.app_config.validation_rule(self)

        # Check result format
        if not isinstance(result, dict):
            raise FeedToWordpressException(
                f"Global validation returns invalid value type."
                f"type: '{type(result)}'. Only allowed type: dict"
            )

        # Update fields with new values
        self._update_fields_from_validator("GlobalValidator",
                                           result)

    def apply_internal_validators(self):

        from feed_to_exporter.filters import GLOBAL_VALIDATOR, \
            INDIVIDUAL_VALIDATORS

        #
        # Apply internal filters
        #
        self._update_fields_from_validator(
            "InternalGlobalValidator",
            GLOBAL_VALIDATOR(self)
        )

        for k, v in self.__dict__.items():
            if not k.startswith("_"):

                #
                # Check if this field has already applied filter
                #
                if k not in self._generated_fields_by_filters:

                    #
                    # Apply individual filters
                    #
                    for f_field, f_function in INDIVIDUAL_VALIDATORS.items():

                        if k == f_field:
                            self._update_fields_from_validator(
                                f_function.__name__,
                                f_function(v)
                            )

    def apply_filters(self):

        try:
            self.apply_internal_validators()
        except FeedToWordpressNotValidInfoFound as e:
            print(f"    <!> Global validation fail: {e}")
            return

        # ---------------------------------------------------------------------
        # Apply filters
        # ---------------------------------------------------------------------
        for key_name, fn_filter in self.app_config.filters.items():
            try:
                self._apply_filter(key_name, fn_filter)
            except FeedToWordpressNotValidInfoFound as e:
                print(f"    <!> Filter {fn_filter.__name__} failed: {e}")
                continue

        # ---------------------------------------------------------------------
        # Apply general validation rule
        # ---------------------------------------------------------------------
        try:
            self.apply_global_validator()
        except FeedToWordpressNotValidInfoFound as e:
            print(f"    <!> Global validation fail: {e}")
            return

    def add_tag(self, name: str, description: str = None):
        self._tags[name] = {
            "description": description
        }

    def add_category(self, name: str,
                     description: str = None,
                     parent_category_name: str = None):
        self._categories[name] = {
            "name": name,
            "description": description or name,
            "parent": parent_category_name or ""
        }

    @property
    @abc.abstractmethod
    def tags(self) -> List:
        """Return the tags a format needed by subsclass"""

    @property
    @abc.abstractmethod
    def categories(self) -> List:
        """Return the tags a format needed by subsclass"""


class AbstractAppConfig:

    def __init__(self,
                 filter_file: str = "filters.py",
                 mapping_path: str = "mapping.json",
                 feed_source: str = None):
        self.feed_source: str = feed_source
        self.filters_file: str = os.path.abspath(filter_file)
        self.mapping_path: str = os.path.abspath(mapping_path)
        self.mapping_json: dict = self._load_json(self.mapping_path)
        self._plugin = None
        self._filter_module = os.path.splitext(
            os.path.basename(self.filters_file)
        )[0]

        #
        # Load filter file as a Python plugin
        #
        if self.filters_file:
            #
            # Load dynamically the source code
            #
            plugin_base = PluginBase(package='feed_to_exporter.plugins')
            self._plugin = plugin_base.make_plugin_source(
                searchpath=[
                    os.path.dirname(self.filters_file)])

        self._target_url_fixed = None
        self._token: dict = None
        self._mapping_obj: SimpleNamespace = None
        self._wordpress_api: str = None

    def _load_json(self, mapping_path: str) -> dict:
        # Load json
        try:
            loaded_mapping = json.load(open(mapping_path, "rb"))
        except IOError as e:
            raise FeedToWordpressException(
                f"Can't find file {self.mapping_path}: {e}")
        except json.decoder.JSONDecodeError:
            raise FeedToWordpressException(
                "Invalid format of JSON file. "
                "Probably you have an error in the JSON format")
        else:

            # If feed property is in mapping.json, overwrite the
            # feed_source
            try:
                self.feed_source = loaded_mapping["feed"]
            except KeyError:
                pass

            if not self.feed_source:
                raise FeedToWordpressException(
                    "Feed Source not provided"
                )

            # -------------------------------------------------------------
            # Check minimum required fields in mapping.json
            # -------------------------------------------------------------
            if "exportMethod" not in loaded_mapping:
                raise FeedToWordpressException(
                    "You must specify property 'exportMethod'. Allowed: "
                    "wordpress|mongo"
                )

            if loaded_mapping["exportMethod"] != self.mode:
                raise FeedToWordpressException(
                    f"[!] Incompatible method for mapping: {mapping_path}."
                    f"    This map is only available for mode: "
                    f"'{loaded_mapping['exportMethod']}'")

        return loaded_mapping

    @property
    def mapping_obj(self) -> SimpleNamespace:
        if not self._mapping_obj:
            temp = json.dumps(self.mapping_json)
            self._mapping_obj = json.loads(
                temp,
                object_hook=lambda d: SimpleNamespace(**d))
        return self._mapping_obj

    @property
    def filters(self):
        m = self._plugin.load_plugin(
            self._filter_module
        )
        return getattr(
            m,
            "INDIVIDUAL_VALIDATORS",
            lambda x: {}
        )

    @property
    def validation_rule(self):
        m = self._plugin.load_plugin(
            self._filter_module
        )
        return getattr(
            m,
            "GLOBAL_VALIDATOR",
            lambda x: {}
        )

    @property
    @abc.abstractmethod
    def mode(self) -> str:
        """Return the name of the method"""

    @abc.abstractmethod
    def push(self, feed_data: dict) -> None:
        """This method perform the action to send the collected data to the
        remote site/db/api..."""


__all__ = ("AbstractAppConfig", "AbstractFeedInfo")

