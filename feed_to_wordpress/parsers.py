import datetime
import feedparser

from slugify import slugify
from typing import List, Callable

from .model import AppConfig
from .wordpress_queries import get_or_create_tag_or_category
from .exceptions import FeedToWordpressException, \
    FeedToWordpressNotValidInfoFound


class FeedInfo:

    def __init__(self,
                 app_config: AppConfig,
                 raw_feed_info: dict,
                 title: str,
                 feed_source: str,
                 pint_status: str = "closed",
                 comment_status: str = "closed",
                 post_status: str = "draft",
                 date: str = None):
        self.title = title
        self.app_config = app_config
        self.pint_status = pint_status
        self.feed_source = feed_source
        self.post_status = post_status
        self.raw_feed_info = raw_feed_info
        self.comment_status = comment_status
        self.date = date or datetime.datetime.now().strftime(
            "%Y-%m-%dT%H:%M:%S")

        self.body = ""
        self.link = ""
        self.content = ""
        self._tags = []
        self._categories = []
        self._generated_fields_by_filters = set()

    def to_wordpress_json(self) -> dict:

        from .filters import GLOBAL_VALIDATOR, INDIVIDUAL_VALIDATORS

        #
        # Apply internal filters
        #
        self._update_fields_from_validator(
            "InternalGlobalValidator",
            GLOBAL_VALIDATOR(self)
        )

        for k, v in self.__dict__.items():
            if not k.startswith("_"):

                #
                # Check if this field has already applied filter
                #
                if k not in self._generated_fields_by_filters:

                    #
                    # Apply individual filters
                    #
                    for f_field, f_function in INDIVIDUAL_VALIDATORS.items():

                        if k == f_field:
                            self._update_fields_from_validator(
                                f_function.__name__,
                                f_function(v)
                            )

        return {
            'title': self.title,
            'content': self.content,
            'slug': slugify(self.title),
            'date': self.date,
            'format': 'standard',
            'status': self.post_status,
            'comment_status': self.comment_status,
            'ping_status': self.pint_status,
            'tags': self.tags,
            'categories': self.categories
        }

    def add_tag(self, tag_name: str, description: str = None):
        tag_id = get_or_create_tag_or_category(
            "tag",
            tag_name,
            self.app_config,
            description
        )

        self._tags.append(tag_id)

    def add_category(self, tag_name: str, description: str = None):
        category_id = get_or_create_tag_or_category(
            "category",
            tag_name,
            self.app_config,
            description
        )

        self._categories.append(category_id)

    @property
    def tags(self) -> List[str]:
        return self._tags

    @property
    def categories(self) -> List[str]:
        return self._categories

    def _update_fields_from_validator(self, source: str, new_values: dict):

        # Update value of fields returned by filter
        for f_name, f_value in new_values.items():
            if hasattr(self, f_name):
                if not f_value:
                    continue

                # If already has a value and is not a list or a dict -> raise
                v = getattr(self, f_name)
                f_type = type(v)
                if f_type.__name__ == "list":
                    v.append(f_value)
                elif f_type.__name__ == "list":
                    v.update(f_value)
                else:
                    setattr(self, f_name, f_value)

            else:
                raise FeedToWordpressException(
                    f"Filter '{source}' returns invalid "
                    f"field to update: {f_name}"
                )

        # Update fields generated by filters
        self._generated_fields_by_filters.update(new_values.keys())

    def apply_filter(self, field_name: str, filter_function: Callable):
        attr_value = getattr(self, field_name)

        # Apply the filter
        filter_result = filter_function(attr_value)

        # Check result format
        if not isinstance(filter_result, dict):
            raise FeedToWordpressException(
                f"Filter '{filter_function.__name__}' returns invalid "
                f"type: '{type(filter_result)}'. Only allowed type: dict"
            )

        # Update fields with new values
        self._update_fields_from_validator(filter_function.__name__,
                                           filter_result)

    def apply_global_validator(self) -> \
            bool or FeedToWordpressNotValidInfoFound:

        result = self.app_config.validation_rule(self)

        # Check result format
        if not isinstance(result, dict):
            raise FeedToWordpressException(
                f"Global validation returns invalid value type."
                f"type: '{type(result)}'. Only allowed type: dict"
            )

        # Update fields with new values
        self._update_fields_from_validator("GlobalValidator",
                                           result)

        return True


def parse_entries(config: AppConfig):
    d = feedparser.parse(config.feed)
    source = d['feed']['title']
    print(f"[*] Parsed feed source: '{source}'")

    for i, new in enumerate(d['entries'], start=1):
        feed_result = FeedInfo(app_config=config,
                               raw_feed_info=new,
                               title=new['title'],
                               feed_source=source)

        print(f"<*> Processing entry: '{i}' - {feed_result.title}")

        # ---------------------------------------------------------------------
        # Only process the feed if there's a key in the map for content
        # ---------------------------------------------------------------------
        if config.mapping_obj.mapping.body not in new:
            print("    <!> This entry hasn't content. Skipping")
            continue

        # ---------------------------------------------------------------------
        # Map input feed key to output Wordpress json format
        # ---------------------------------------------------------------------
        for out_key, in_key in config.mapping_json['mapping'].items():
            setattr(feed_result, out_key, new.get(in_key))

        # ---------------------------------------------------------------------
        # Attach fixed fields
        # ---------------------------------------------------------------------
        if hasattr(config.mapping_obj, "fixed"):
            for k, v in config.mapping_json['fixed'].items():

                if "tag" in k:
                    feed_result.add_tag(v)
                elif "categories" in k:
                    feed_result.add_category(v)
                else:
                    setattr(feed_result, k, v)

        # ---------------------------------------------------------------------
        # Apply filters
        # ---------------------------------------------------------------------
        for key_name, fn_filter in config.filters.items():
            try:
                feed_result.apply_filter(key_name, fn_filter)
            except FeedToWordpressNotValidInfoFound as e:
                print(f"    <!> Filter {fn_filter.__name__} failed: {e}")
                continue

        # ---------------------------------------------------------------------
        # Apply general validation rule
        # ---------------------------------------------------------------------
        try:
            feed_result.apply_global_validator()
        except FeedToWordpressNotValidInfoFound as e:
            print(f"    <!> Global validation fail: {e}")
            continue

        # Yield the content ready to send to Wordpress
        yield feed_result.to_wordpress_json()


__all__ = ("FeedInfo", "parse_entries")

